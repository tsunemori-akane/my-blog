---
title: "jsæ¨¡å—åŒ–"
description: "jsæ¨¡å—åŒ–"
---

## What are Modules?
<Callout>
  Good authors divide their books into chapters and sections; good programmers divide their 
  programs into modules. 
</Callout>
## Benefits of using modules 
Using modules in favor of sprawing, interdependent codebase.
- **Maintainability** <br/>
  Updating a single module will be much more easier when the module is decoupled from other pieces of codebase.
- **Reusability** <br/>
  A module that we can reuse over and over again without ctrl+v all around.

## Incorporate modules into programs
- the common approaches is use a single global variable to wrap code in a function, thereby creating a private 
  namespace for itself using a closure scope.
- if your programs relys on many other dependencies, you need to know the right order to load files in, that is troublesome.
- loading other dependencies can still lead to namespace collisions. For examples, what if two of your modules have the same name?
  Or waht if you have two versions of module, and you need both? The **CommonJS** and **AMD** are the answer!


### CommonJS
> Note that CommonJS takes a server-first approach and **synchronously** loads modules.
> this looks great on the server but, unfortunately, makes it harder to use when writing JS for browser
> Reading a module from the web takes a lot longer than reading from disk.
> For as long as the script to load a module is running, it blocks the browser from running annything else until it finishes the loading.
> It behaves the way because the JS thread stops until the code has been loaded.

### AMD
Shorhands of Asynchronous Module Definition

```js
define(['moduleA', 'moduleB'], function(moduleA, moduleB) {
  moduleA.hello();
})
```

```js title="moduleA.js"
define("moduleA",[], function() {
  return {
    hello: function() {
      console.log('hello')
    }
  }
})
```
more resource 
- [exploringjs.com](exploringjs.com/es6/ch_modules.html)
- [AMD.md](https://github.com/amdjs/amdjs-api/blob/master/AMD.md)

## ES6 modules
<Callout>
  Compare to CommonJS, `imports` in ES6 modules are **live**  
</Callout>


```js title="counter.js"
var count = 1;
function increment() {
  count++;
}
function decrement() {
  count--;
}
module.exports = {
  count: count,
  increment: increment,
  decrement: decrement
};
``` 
```js title="main.js" showLineNumbers {4}
var counter = require('./counter.js');

counter.increment();
console.log(counter.count); // 1
```
How is it possible be one?ğŸ¤”Because the `count` variable we imported is a disconnected copy and incrementing the count 
will increment it in the module(function is't primitive value, it is just a reference), but won't increment the copied version.

```js
// ./counter.js
export let count = 1;
export function increment() {
  count++;
}
export function decrement() {
  count--;
}
// ./main.js
import * as counter from './counter';

console.log(counter.count); // 1
counter.increment();
console.log(counter.count); // 2
```
[The imports of an ES6 module are read-only views on the exported entities.](https://exploringjs.com/es6/ch_modules.html#_imports-are-read-only-views-on-exports)
, which means there are following advantages<br/>

- They enable cyclic dependencies(two modules depend on each other), even for unqualified imports.
- Qualified and unqualified imports work the same way (they are both indirections).
- You can split code into multiple modules and it will continue to work (as long as you don't try to change the values of imports).
> The Most important things, ES6 Modules are designed with static analysis. When you import modules,
> the import is resolved at compile time - that is, before the script starts executing.
> This allows us to remove exports that are not used by other modules before we run the program.
> Removing unused exports and  can lead to significant space saving, reducing stress on the browser
> The approach to eliminate dead code, called "**tree shaking**"

### Cyclic dependencies in CommonJS
```js showLineNumbers 
//index.js
var a = require('./a')
var b= require('./b')

// a.js
module.exports.a = 'åŸå§‹å€¼-aæ¨¡å—å†…å˜é‡'
console.log('aæ¨¡å—æ‰§è¡Œ')
var c = require('./c')

// b.js
module.exports.b = 'åŸå§‹å€¼-bæ¨¡å—å†…å˜é‡'
console.log('bæ¨¡å—æ‰§è¡Œ')
var c = require('./c')

// c.js
module.exports.c = 'åŸå§‹å€¼-cæ¨¡å—å†…å˜é‡'
console.log('cæ¨¡å—æ‰§è¡Œ')
```
> è¾“å‡º: aæ¨¡å—æ‰§è¡Œ cæ¨¡å—æ‰§è¡Œ bæ¨¡å—æ‰§è¡Œ<br/>
> ä¸ºä»€ä¹ˆä»…åœ¨ç¬¬8è¡Œrequireåè¾“å‡º â€œcæ¨¡å—æ‰§è¡Œâ€ , 13è¡Œrequireåä¸å†è¾“å‡ºäº†<br/>
> å› ä¸ºç¬¬ä¸€æ¬¡æ‰§è¡Œcæ¨¡å—, CommonJSä¼šå°†å®ƒç¼“å­˜èµ·æ¥, ç›¸å½“äºæ‹·è´ä¸€ä»½, æ”¾åœ¨ä¸€å—æ–°çš„å†…å­˜ä¸­

### Cyclic dependencies in ESModule

ES moduleå¯¼å‡ºçš„æ˜¯ä¸€ä¸ªç´¢å¼•â€”â€”å†…å­˜åœ°å€, æ²¡æœ‰åŠæ³•è¿™æ ·å¤„ç†. 
åœ¨ä»£ç æ‰§è¡Œå‰, é¦–å…ˆè¦è¿›è¡Œé¢„å¤„ç†, è¿™ä¸€æ­¥ä¼šæ ¹æ®importå’Œexportæ¥æ„å»ºæ¨¡å—åœ°å›¾`Module Map`, å®ƒç±»ä¼¼äºä¸€é¢—æ ‘, æ ‘ä¸­çš„æ¯ä¸€ä¸ªâ€œèŠ‚ç‚¹â€å°±æ˜¯ä¸€ä¸ªæ¨¡å—è®°å½•, è¿™ä¸ªè®°å½•ä¸Šä¼šæ ‡æ³¨å¯¼å‡ºå˜é‡çš„å†…å­˜åœ°å€, å°†å¯¼å…¥çš„å˜é‡å’Œå¯¼å‡ºçš„å˜é‡è¿æ¥, å³æŠŠä»–ä»¬æŒ‡å‘åŒä¸€å—å†…å­˜åœ°å€, ä¸è¿‡æ­¤æ—¶è¿™äº›å†…å­˜éƒ½æ˜¯ç©ºçš„`uninitialized`

```js showLineNumbers
// index.mjs
import * as a from './a.mjs' //æ‰“æ–­ç‚¹debug -> step into -> è·³è½¬åˆ°13è¡Œ
console.log('å…¥å£å¼•ç”¨a:',a)

// a.mjs
import * as b from "./b.mjs"
let a = "AAA"
console.log("aå¼•ç”¨b:", b)
export { a }

// b.mjs
import * as a from "./a.mjs"
let b = "BBB"     // ç”±ç¬¬2è¡Œè·³è½¬è¿‡æ¥
console.log("bå¼•ç”¨a:", a) //æ²¡æ‰“å°å‡ºæ¥
export { b }
```
- æ‰“å°å¦‚ä¸‹
<Image src="/images/jsbundle/cyclic-dependencies-in-esmodule.webp" height='400' width='400' alt="webp" />

- `.vscode`ç›®å½•ä¸‹launch.jsoné…ç½®
```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Launch Program",
      "program": "${workspaceFolder}/test/cyclic_dependencies/index.mjs", //workspaceFolderæ˜¯å½“å‰æ‰“å¼€çš„æœ€ä¸Šå±‚ç›®å½•
      "request": "launch",
      "skipFiles": [
        "<node_internals>/**"
      ],
      "type": "node",
      "runtimeExecutable": "/usr/local/bin/node"
    },
  ]
}
```